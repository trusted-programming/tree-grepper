use crate::backtrace::Backtrace;
use crate::chain::Chain;
#[cfg(any(feature = "std", anyhow_no_ptr_addr_of))]
use crate::ptr::Mut;
use crate::ptr::{Own, Ref};
use crate::{Error, StdError};
use alloc::boxed::Box;
use core::any::TypeId;
use core::fmt::{self, Debug, Display};
use core::mem::ManuallyDrop;
#[cfg(not(anyhow_no_ptr_addr_of))]
use core::ptr;
use core::ptr::NonNull;

#[cfg(feature = "std")]
use core::ops::{Deref, DerefMut};

<SAFENESS></SAFENESS>impl Error {
    
    
    
    
    
    
    
    #[cfg(feature = "std")]
    #[cfg_attr(doc_cfg, doc(cfg(feature = "std")))]
    #[cold]
    #[must_use]
    <SAFENESS></SAFENESS>pub fn new<E>(<MUTABLE></MUTABLE>error: E) -> Self
    where
        E: StdError + Send + Sync <LIFETIME>'static</LIFETIME>,
    {
        let <MUTABLE></MUTABLE> backtrace = backtrace_if_absent!(error);
        Error::from_std(error, backtrace)
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[cold]
    #[must_use]
    <SAFENESS></SAFENESS>pub fn msg<M>(<MUTABLE></MUTABLE>message: M) -> Self
    where
        M: Display + Debug + Send + Sync <LIFETIME>'static</LIFETIME>,
    {
        Error::from_adhoc(message, backtrace!())
    }

    #[cfg(feature = "std")]
    #[cold]
    <SAFENESS></SAFENESS>pub(crate) fn from_std<E>(<MUTABLE></MUTABLE>error: E, <MUTABLE></MUTABLE>backtrace: Option<LIFETIME></LIFETIME><Backtrace>) -> Self
    where
        E: StdError + Send + Sync <LIFETIME>'static</LIFETIME>,
    {
        let <MUTABLE></MUTABLE> vtable = &ErrorVTable {
            object_drop: object_drop::<LIFETIME></LIFETIME><E>,
            object_ref: object_ref::<LIFETIME></LIFETIME><E>,
            #[cfg(anyhow_no_ptr_addr_of)]
            object_mut: object_mut::<LIFETIME></LIFETIME><E>,
            object_boxed: object_boxed::<LIFETIME></LIFETIME><E>,
            object_downcast: object_downcast::<LIFETIME></LIFETIME><E>,
            #[cfg(anyhow_no_ptr_addr_of)]
            object_downcast_mut: object_downcast_mut::<LIFETIME></LIFETIME><E>,
            object_drop_rest: object_drop_front::<LIFETIME></LIFETIME><E>,
            #[cfg(all(not(backtrace), feature = "backtrace"))]
            object_backtrace: no_backtrace,
        };

        
        <SAFENESS>unsafe</SAFENESS> { Error::construct(error, vtable, backtrace) }
    }

    #[cold]
    <SAFENESS></SAFENESS>pub(crate) fn from_adhoc<M>(<MUTABLE></MUTABLE>message: M, <MUTABLE></MUTABLE>backtrace: Option<LIFETIME></LIFETIME><Backtrace>) -> Self
    where
        M: Display + Debug + Send + Sync <LIFETIME>'static</LIFETIME>,
    {
        use crate::wrapper::MessageError;
        let <MUTABLE></MUTABLE> error: MessageError<LIFETIME></LIFETIME><M> = MessageError(message);
        let <MUTABLE></MUTABLE> vtable = &ErrorVTable {
            object_drop: object_drop::<LIFETIME></LIFETIME><MessageError<LIFETIME></LIFETIME><M>>,
            object_ref: object_ref::<LIFETIME></LIFETIME><MessageError<LIFETIME></LIFETIME><M>>,
            #[cfg(all(feature = "std", anyhow_no_ptr_addr_of))]
            object_mut: object_mut::<LIFETIME></LIFETIME><MessageError<LIFETIME></LIFETIME><M>>,
            object_boxed: object_boxed::<LIFETIME></LIFETIME><MessageError<LIFETIME></LIFETIME><M>>,
            object_downcast: object_downcast::<LIFETIME></LIFETIME><M>,
            #[cfg(anyhow_no_ptr_addr_of)]
            object_downcast_mut: object_downcast_mut::<LIFETIME></LIFETIME><M>,
            object_drop_rest: object_drop_front::<LIFETIME></LIFETIME><M>,
            #[cfg(all(not(backtrace), feature = "backtrace"))]
            object_backtrace: no_backtrace,
        };

        
        
        <SAFENESS>unsafe</SAFENESS> { Error::construct(error, vtable, backtrace) }
    }

    #[cold]
    <SAFENESS></SAFENESS>pub(crate) fn from_display<M>(<MUTABLE></MUTABLE>message: M, <MUTABLE></MUTABLE>backtrace: Option<LIFETIME></LIFETIME><Backtrace>) -> Self
    where
        M: Display + Send + Sync <LIFETIME>'static</LIFETIME>,
    {
        use crate::wrapper::DisplayError;
        let <MUTABLE></MUTABLE> error: DisplayError<LIFETIME></LIFETIME><M> = DisplayError(message);
        let <MUTABLE></MUTABLE> vtable = &ErrorVTable {
            object_drop: object_drop::<LIFETIME></LIFETIME><DisplayError<LIFETIME></LIFETIME><M>>,
            object_ref: object_ref::<LIFETIME></LIFETIME><DisplayError<LIFETIME></LIFETIME><M>>,
            #[cfg(all(feature = "std", anyhow_no_ptr_addr_of))]
            object_mut: object_mut::<LIFETIME></LIFETIME><DisplayError<LIFETIME></LIFETIME><M>>,
            object_boxed: object_boxed::<LIFETIME></LIFETIME><DisplayError<LIFETIME></LIFETIME><M>>,
            object_downcast: object_downcast::<LIFETIME></LIFETIME><M>,
            #[cfg(anyhow_no_ptr_addr_of)]
            object_downcast_mut: object_downcast_mut::<LIFETIME></LIFETIME><M>,
            object_drop_rest: object_drop_front::<LIFETIME></LIFETIME><M>,
            #[cfg(all(not(backtrace), feature = "backtrace"))]
            object_backtrace: no_backtrace,
        };

        
        
        <SAFENESS>unsafe</SAFENESS> { Error::construct(error, vtable, backtrace) }
    }

    #[cfg(feature = "std")]
    #[cold]
    <SAFENESS></SAFENESS>pub(crate) fn from_context<C, E>(<MUTABLE></MUTABLE>context: C, <MUTABLE></MUTABLE>error: E, <MUTABLE></MUTABLE>backtrace: Option<LIFETIME></LIFETIME><Backtrace>) -> Self
    where
        C: Display + Send + Sync <LIFETIME>'static</LIFETIME>,
        E: StdError + Send + Sync <LIFETIME>'static</LIFETIME>,
    {
        let <MUTABLE></MUTABLE> error: ContextError<LIFETIME></LIFETIME><C, E> = ContextError { context, error };

        let <MUTABLE></MUTABLE> vtable = &ErrorVTable {
            object_drop: object_drop::<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, E>>,
            object_ref: object_ref::<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, E>>,
            #[cfg(anyhow_no_ptr_addr_of)]
            object_mut: object_mut::<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, E>>,
            object_boxed: object_boxed::<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, E>>,
            object_downcast: context_downcast::<LIFETIME></LIFETIME><C, E>,
            #[cfg(anyhow_no_ptr_addr_of)]
            object_downcast_mut: context_downcast_mut::<LIFETIME></LIFETIME><C, E>,
            object_drop_rest: context_drop_rest::<LIFETIME></LIFETIME><C, E>,
            #[cfg(all(not(backtrace), feature = "backtrace"))]
            object_backtrace: no_backtrace,
        };

        
        <SAFENESS>unsafe</SAFENESS> { Error::construct(error, vtable, backtrace) }
    }

    #[cfg(feature = "std")]
    #[cold]
    <SAFENESS></SAFENESS>pub(crate) fn from_boxed(
        <MUTABLE></MUTABLE>error: Box<LIFETIME></LIFETIME><dyn StdError + Send + Sync>,
        <MUTABLE></MUTABLE>backtrace: Option<LIFETIME></LIFETIME><Backtrace>,
    ) -> Self {
        use crate::wrapper::BoxedError;
        let <MUTABLE></MUTABLE> error = BoxedError(error);
        let <MUTABLE></MUTABLE> vtable = &ErrorVTable {
            object_drop: object_drop::<LIFETIME></LIFETIME><BoxedError>,
            object_ref: object_ref::<LIFETIME></LIFETIME><BoxedError>,
            #[cfg(anyhow_no_ptr_addr_of)]
            object_mut: object_mut::<LIFETIME></LIFETIME><BoxedError>,
            object_boxed: object_boxed::<LIFETIME></LIFETIME><BoxedError>,
            object_downcast: object_downcast::<LIFETIME></LIFETIME><Box<LIFETIME></LIFETIME><dyn StdError + Send + Sync>>,
            #[cfg(anyhow_no_ptr_addr_of)]
            object_downcast_mut: object_downcast_mut::<LIFETIME></LIFETIME><Box<LIFETIME></LIFETIME><dyn StdError + Send + Sync>>,
            object_drop_rest: object_drop_front::<LIFETIME></LIFETIME><Box<LIFETIME></LIFETIME><dyn StdError + Send + Sync>>,
            #[cfg(all(not(backtrace), feature = "backtrace"))]
            object_backtrace: no_backtrace,
        };

        
        
        <SAFENESS>unsafe</SAFENESS> { Error::construct(error, vtable, backtrace) }
    }

    
    
    
    
    
    #[cold]
    <SAFENESS>unsafe</SAFENESS> fn construct<E>(
        <MUTABLE></MUTABLE>error: E,
        <MUTABLE></MUTABLE>vtable: <LIFETIME></LIFETIME>&<LIFETIME>'static</LIFETIME> ErrorVTable,
        <MUTABLE></MUTABLE>backtrace: Option<LIFETIME></LIFETIME><Backtrace>,
    ) -> Self
    where
        E: StdError + Send + Sync <LIFETIME>'static</LIFETIME>,
    {
        let <MUTABLE></MUTABLE> inner: Box<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><E>> = Box::new(ErrorImpl {
            vtable,
            backtrace,
            _object: error,
        });
        
        
        
        
        
        
        let <MUTABLE></MUTABLE> inner = Own::new(inner).cast::<LIFETIME></LIFETIME><ErrorImpl>();
        Error { inner }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[cold]
    #[must_use]
    <SAFENESS></SAFENESS>pub fn context<C>(<MUTABLE></MUTABLE>self, <MUTABLE></MUTABLE>context: C) -> Self
    where
        C: Display + Send + Sync <LIFETIME>'static</LIFETIME>,
    {
        let <MUTABLE></MUTABLE> error: ContextError<LIFETIME></LIFETIME><C, Error> = ContextError {
            context,
            error: self,
        };

        let <MUTABLE></MUTABLE> vtable = &ErrorVTable {
            object_drop: object_drop::<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, Error>>,
            object_ref: object_ref::<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, Error>>,
            #[cfg(all(feature = "std", anyhow_no_ptr_addr_of))]
            object_mut: object_mut::<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, Error>>,
            object_boxed: object_boxed::<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, Error>>,
            object_downcast: context_chain_downcast::<LIFETIME></LIFETIME><C>,
            #[cfg(anyhow_no_ptr_addr_of)]
            object_downcast_mut: context_chain_downcast_mut::<LIFETIME></LIFETIME><C>,
            object_drop_rest: context_chain_drop_rest::<LIFETIME></LIFETIME><C>,
            #[cfg(all(not(backtrace), feature = "backtrace"))]
            object_backtrace: context_backtrace::<LIFETIME></LIFETIME><C>,
        };

        
        let <MUTABLE></MUTABLE> backtrace = None;

        
        <SAFENESS>unsafe</SAFENESS> { Error::construct(error, vtable, backtrace) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[cfg(any(backtrace, feature = "backtrace"))]
    #[cfg_attr(doc_cfg, doc(cfg(any(nightly, feature = "backtrace"))))]
    <SAFENESS></SAFENESS>pub fn backtrace(<MUTABLE></MUTABLE>&<MUTABLE></MUTABLE>self) -> <LIFETIME></LIFETIME>&impl_backtrace!() {
        <SAFENESS>unsafe</SAFENESS> { ErrorImpl::backtrace(self.inner.by_ref()) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[cfg(feature = "std")]
    #[cfg_attr(doc_cfg, doc(cfg(feature = "std")))]
    #[cold]
    <SAFENESS></SAFENESS>pub fn chain(<MUTABLE></MUTABLE>&<MUTABLE></MUTABLE>self) -> Chain {
        <SAFENESS>unsafe</SAFENESS> { ErrorImpl::chain(self.inner.by_ref()) }
    }

    
    
    
    
    
    #[cfg(feature = "std")]
    #[cfg_attr(doc_cfg, doc(cfg(feature = "std")))]
    <SAFENESS></SAFENESS>pub fn root_cause(<MUTABLE></MUTABLE>&<MUTABLE></MUTABLE>self) -> <LIFETIME></LIFETIME>&(dyn StdError <LIFETIME>'static</LIFETIME>) {
        self.chain().last().unwrap()
    }

    
    
    
    
    
    
    
    
    <SAFENESS></SAFENESS>pub fn is<E>(<MUTABLE></MUTABLE>&<MUTABLE></MUTABLE>self) -> bool
    where
        E: Display + Debug + Send + Sync <LIFETIME>'static</LIFETIME>,
    {
        self.downcast_ref::<LIFETIME></LIFETIME><E>().is_some()
    }

    
    <SAFENESS></SAFENESS>pub fn downcast<E>(<MUTABLE>mut</MUTABLE> self) -> Result<LIFETIME></LIFETIME><E, Self>
    where
        E: Display + Debug + Send + Sync <LIFETIME>'static</LIFETIME>,
    {
        let <MUTABLE></MUTABLE> target = TypeId::of::<LIFETIME></LIFETIME><E>();
        let <MUTABLE></MUTABLE> inner = self.inner.by_mut();
        <SAFENESS>unsafe</SAFENESS> {
            
            
            #[cfg(not(anyhow_no_ptr_addr_of))]
            let <MUTABLE></MUTABLE> addr = match (vtable(inner.ptr).object_downcast)(inner.by_ref(), target) {
                Some(addr) => addr.by_mut().extend(),
                None => return Err(self),
            };
            #[cfg(anyhow_no_ptr_addr_of)]
            let <MUTABLE></MUTABLE> addr = match (vtable(inner.ptr).object_downcast_mut)(inner, target) {
                Some(addr) => addr.extend(),
                None => return Err(self),
            };

            
            
            let <MUTABLE></MUTABLE> outer = ManuallyDrop::new(self);

            
            let <MUTABLE></MUTABLE> error = addr.cast::<LIFETIME></LIFETIME><E>().read();

            
            (vtable(outer.inner.ptr).object_drop_rest)(outer.inner, target);

            Ok(error)
        }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <SAFENESS></SAFENESS>pub fn downcast_ref<E>(<MUTABLE></MUTABLE>&<MUTABLE></MUTABLE>self) -> Option<LIFETIME></LIFETIME><<LIFETIME></LIFETIME>&E>
    where
        E: Display + Debug + Send + Sync <LIFETIME>'static</LIFETIME>,
    {
        let <MUTABLE></MUTABLE> target = TypeId::of::<LIFETIME></LIFETIME><E>();
        <SAFENESS>unsafe</SAFENESS> {
            
            
            let <MUTABLE></MUTABLE> addr = (vtable(self.inner.ptr).object_downcast)(self.inner.by_ref(), target)?;
            Some(addr.cast::<LIFETIME></LIFETIME><E>().deref())
        }
    }

    
    <SAFENESS></SAFENESS>pub fn downcast_mut<E>(&<MUTABLE>mut</MUTABLE> self) -> Option<LIFETIME></LIFETIME><<LIFETIME></LIFETIME>&<MUTABLE>mut</MUTABLE> E>
    where
        E: Display + Debug + Send + Sync <LIFETIME>'static</LIFETIME>,
    {
        let <MUTABLE></MUTABLE> target = TypeId::of::<LIFETIME></LIFETIME><E>();
        <SAFENESS>unsafe</SAFENESS> {
            
            

            #[cfg(not(anyhow_no_ptr_addr_of))]
            let <MUTABLE></MUTABLE> addr =
                (vtable(self.inner.ptr).object_downcast)(self.inner.by_ref(), target)?.by_mut();

            #[cfg(anyhow_no_ptr_addr_of)]
            let <MUTABLE></MUTABLE> addr = (vtable(self.inner.ptr).object_downcast_mut)(self.inner.by_mut(), target)?;

            Some(addr.cast::<LIFETIME></LIFETIME><E>().deref_mut())
        }
    }
}

#[cfg(feature = "std")]
#[cfg_attr(doc_cfg, doc(cfg(feature = "std")))]
<SAFENESS></SAFENESS>impl<E> From<LIFETIME></LIFETIME><E> for Error
where
    E: StdError + Send + Sync <LIFETIME>'static</LIFETIME>,
{
    #[cold]
    <SAFENESS></SAFENESS>fn from(<MUTABLE></MUTABLE>error: E) -> Self {
        let <MUTABLE></MUTABLE> backtrace = backtrace_if_absent!(error);
        Error::from_std(error, backtrace)
    }
}

#[cfg(feature = "std")]
#[cfg_attr(doc_cfg, doc(cfg(feature = "std")))]
<SAFENESS></SAFENESS>impl Deref for Error {
    type Target = dyn StdError + Send + Sync <LIFETIME>'static</LIFETIME>;

    <SAFENESS></SAFENESS>fn deref(<MUTABLE></MUTABLE>&<MUTABLE></MUTABLE>self) -> <LIFETIME></LIFETIME>&Self::Target {
        <SAFENESS>unsafe</SAFENESS> { ErrorImpl::error(self.inner.by_ref()) }
    }
}

#[cfg(feature = "std")]
#[cfg_attr(doc_cfg, doc(cfg(feature = "std")))]
<SAFENESS></SAFENESS>impl DerefMut for Error {
    <SAFENESS></SAFENESS>fn deref_mut(&<MUTABLE>mut</MUTABLE> self) -> <LIFETIME></LIFETIME>&<MUTABLE>mut</MUTABLE> Self::Target {
        <SAFENESS>unsafe</SAFENESS> { ErrorImpl::error_mut(self.inner.by_mut()) }
    }
}

<SAFENESS></SAFENESS>impl Display for Error {
    <SAFENESS></SAFENESS>fn fmt(<MUTABLE></MUTABLE>&<MUTABLE></MUTABLE>self, <MUTABLE></MUTABLE>formatter: <LIFETIME></LIFETIME>&<MUTABLE>mut</MUTABLE> fmt::Formatter) -> fmt::Result {
        <SAFENESS>unsafe</SAFENESS> { ErrorImpl::display(self.inner.by_ref(), formatter) }
    }
}

<SAFENESS></SAFENESS>impl Debug for Error {
    <SAFENESS></SAFENESS>fn fmt(<MUTABLE></MUTABLE>&<MUTABLE></MUTABLE>self, <MUTABLE></MUTABLE>formatter: <LIFETIME></LIFETIME>&<MUTABLE>mut</MUTABLE> fmt::Formatter) -> fmt::Result {
        <SAFENESS>unsafe</SAFENESS> { ErrorImpl::debug(self.inner.by_ref(), formatter) }
    }
}

<SAFENESS></SAFENESS>impl Drop for Error {
    <SAFENESS></SAFENESS>fn drop(&<MUTABLE>mut</MUTABLE> self) {
        <SAFENESS>unsafe</SAFENESS> {
            
            (vtable(self.inner.ptr).object_drop)(self.inner);
        }
    }
}

struct ErrorVTable {
    object_drop: <SAFENESS></SAFENESS><SAFENESS>unsafe</SAFENESS> fn(Own<LIFETIME></LIFETIME><ErrorImpl>),
    object_ref: <SAFENESS></SAFENESS><SAFENESS>unsafe</SAFENESS> fn(Ref<LIFETIME></LIFETIME><ErrorImpl>) -> Ref<LIFETIME></LIFETIME><dyn StdError + Send + Sync <LIFETIME>'static</LIFETIME>>,
    #[cfg(all(feature = "std", anyhow_no_ptr_addr_of))]
    object_mut: <SAFENESS></SAFENESS><SAFENESS>unsafe</SAFENESS> fn(Mut<LIFETIME></LIFETIME><ErrorImpl>) -> <LIFETIME></LIFETIME>&<MUTABLE>mut</MUTABLE> (dyn StdError + Send + Sync <LIFETIME>'static</LIFETIME>),
    object_boxed: <SAFENESS></SAFENESS><SAFENESS>unsafe</SAFENESS> fn(Own<LIFETIME></LIFETIME><ErrorImpl>) -> Box<LIFETIME></LIFETIME><dyn StdError + Send + Sync <LIFETIME>'static</LIFETIME>>,
    object_downcast: <SAFENESS></SAFENESS><SAFENESS>unsafe</SAFENESS> fn(Ref<LIFETIME></LIFETIME><ErrorImpl>, TypeId) -> Option<LIFETIME></LIFETIME><Ref<LIFETIME></LIFETIME><()>>,
    #[cfg(anyhow_no_ptr_addr_of)]
    object_downcast_mut: <SAFENESS></SAFENESS><SAFENESS>unsafe</SAFENESS> fn(Mut<LIFETIME></LIFETIME><ErrorImpl>, TypeId) -> Option<LIFETIME></LIFETIME><Mut<LIFETIME></LIFETIME><()>>,
    object_drop_rest: <SAFENESS></SAFENESS><SAFENESS>unsafe</SAFENESS> fn(Own<LIFETIME></LIFETIME><ErrorImpl>, TypeId),
    #[cfg(all(not(backtrace), feature = "backtrace"))]
    object_backtrace: <SAFENESS></SAFENESS><SAFENESS>unsafe</SAFENESS> fn(Ref<LIFETIME></LIFETIME><ErrorImpl>) -> Option<LIFETIME></LIFETIME><<LIFETIME></LIFETIME>&Backtrace>,
}


<SAFENESS>unsafe</SAFENESS> fn object_drop<E>(<MUTABLE></MUTABLE>e: Own<LIFETIME></LIFETIME><ErrorImpl>) {
    
    
    let <MUTABLE></MUTABLE> unerased = e.cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><E>>().boxed();
    drop(unerased);
}


<SAFENESS>unsafe</SAFENESS> fn object_drop_front<E>(<MUTABLE></MUTABLE>e: Own<LIFETIME></LIFETIME><ErrorImpl>, <MUTABLE></MUTABLE>target: TypeId) {
    
    
    
    let <MUTABLE></MUTABLE> _ = target;
    let <MUTABLE></MUTABLE> unerased = e.cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><ManuallyDrop<LIFETIME></LIFETIME><E>>>().boxed();
    drop(unerased);
}


<SAFENESS>unsafe</SAFENESS> fn object_ref<E>(<MUTABLE></MUTABLE>e: Ref<LIFETIME></LIFETIME><ErrorImpl>) -> Ref<LIFETIME></LIFETIME><dyn StdError + Send + Sync <LIFETIME>'static</LIFETIME>>
where
    E: StdError + Send + Sync <LIFETIME>'static</LIFETIME>,
{
    

    let <MUTABLE></MUTABLE> unerased = e.cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><E>>();

    #[cfg(not(anyhow_no_ptr_addr_of))]
    return Ref::from_raw(NonNull::new_unchecked(
        ptr::addr_of!((*unerased.as_ptr())._object) as *<MUTABLE>mut</MUTABLE> E,
    ));

    #[cfg(anyhow_no_ptr_addr_of)]
    return Ref::new(&unerased.deref()._object);
}



#[cfg(all(feature = "std", anyhow_no_ptr_addr_of))]
<SAFENESS>unsafe</SAFENESS> fn object_mut<E>(<MUTABLE></MUTABLE>e: Mut<LIFETIME></LIFETIME><ErrorImpl>) -> <LIFETIME></LIFETIME>&<MUTABLE>mut</MUTABLE> (dyn StdError + Send + Sync <LIFETIME>'static</LIFETIME>)
where
    E: StdError + Send + Sync <LIFETIME>'static</LIFETIME>,
{
    
    &<MUTABLE>mut</MUTABLE> e.cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><E>>().deref_mut()._object
}


<SAFENESS>unsafe</SAFENESS> fn object_boxed<E>(<MUTABLE></MUTABLE>e: Own<LIFETIME></LIFETIME><ErrorImpl>) -> Box<LIFETIME></LIFETIME><dyn StdError + Send + Sync <LIFETIME>'static</LIFETIME>>
where
    E: StdError + Send + Sync <LIFETIME>'static</LIFETIME>,
{
    
    e.cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><E>>().boxed()
}


<SAFENESS>unsafe</SAFENESS> fn object_downcast<E>(<MUTABLE></MUTABLE>e: Ref<LIFETIME></LIFETIME><ErrorImpl>, <MUTABLE></MUTABLE>target: TypeId) -> Option<LIFETIME></LIFETIME><Ref<LIFETIME></LIFETIME><()>>
where
    E: <LIFETIME>'static</LIFETIME>,
{
    if TypeId::of::<LIFETIME></LIFETIME><E>() == target {
        
        

        let <MUTABLE></MUTABLE> unerased = e.cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><E>>();

        #[cfg(not(anyhow_no_ptr_addr_of))]
        return Some(
            Ref::from_raw(NonNull::new_unchecked(
                ptr::addr_of!((*unerased.as_ptr())._object) as *<MUTABLE>mut</MUTABLE> E,
            ))
            .cast::<LIFETIME></LIFETIME><()>(),
        );

        #[cfg(anyhow_no_ptr_addr_of)]
        return Some(Ref::new(&unerased.deref()._object).cast::<LIFETIME></LIFETIME><()>());
    } else {
        None
    }
}


#[cfg(anyhow_no_ptr_addr_of)]
<SAFENESS>unsafe</SAFENESS> fn object_downcast_mut<E>(<MUTABLE></MUTABLE>e: Mut<LIFETIME></LIFETIME><ErrorImpl>, <MUTABLE></MUTABLE>target: TypeId) -> Option<LIFETIME></LIFETIME><Mut<LIFETIME></LIFETIME><()>>
where
    E: <LIFETIME>'static</LIFETIME>,
{
    if TypeId::of::<LIFETIME></LIFETIME><E>() == target {
        
        
        let <MUTABLE></MUTABLE> unerased = e.cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><E>>().deref_mut();
        Some(Mut::new(&<MUTABLE>mut</MUTABLE> unerased._object).cast::<LIFETIME></LIFETIME><()>())
    } else {
        None
    }
}

#[cfg(all(not(backtrace), feature = "backtrace"))]
<SAFENESS></SAFENESS>fn no_backtrace(<MUTABLE></MUTABLE>e: Ref<LIFETIME></LIFETIME><ErrorImpl>) -> Option<LIFETIME></LIFETIME><<LIFETIME></LIFETIME>&Backtrace> {
    let <MUTABLE></MUTABLE> _ = e;
    None
}


#[cfg(feature = "std")]
<SAFENESS>unsafe</SAFENESS> fn context_downcast<C, E>(<MUTABLE></MUTABLE>e: Ref<LIFETIME></LIFETIME><ErrorImpl>, <MUTABLE></MUTABLE>target: TypeId) -> Option<LIFETIME></LIFETIME><Ref<LIFETIME></LIFETIME><()>>
where
    C: <LIFETIME>'static</LIFETIME>,
    E: <LIFETIME>'static</LIFETIME>,
{
    if TypeId::of::<LIFETIME></LIFETIME><C>() == target {
        let <MUTABLE></MUTABLE> unerased = e.cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, E>>>().deref();
        Some(Ref::new(&unerased._object.context).cast::<LIFETIME></LIFETIME><()>())
    } else if TypeId::of::<LIFETIME></LIFETIME><E>() == target {
        let <MUTABLE></MUTABLE> unerased = e.cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, E>>>().deref();
        Some(Ref::new(&unerased._object.error).cast::<LIFETIME></LIFETIME><()>())
    } else {
        None
    }
}


#[cfg(all(feature = "std", anyhow_no_ptr_addr_of))]
<SAFENESS>unsafe</SAFENESS> fn context_downcast_mut<C, E>(<MUTABLE></MUTABLE>e: Mut<LIFETIME></LIFETIME><ErrorImpl>, <MUTABLE></MUTABLE>target: TypeId) -> Option<LIFETIME></LIFETIME><Mut<LIFETIME></LIFETIME><()>>
where
    C: <LIFETIME>'static</LIFETIME>,
    E: <LIFETIME>'static</LIFETIME>,
{
    if TypeId::of::<LIFETIME></LIFETIME><C>() == target {
        let <MUTABLE></MUTABLE> unerased = e.cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, E>>>().deref_mut();
        Some(Mut::new(&<MUTABLE>mut</MUTABLE> unerased._object.context).cast::<LIFETIME></LIFETIME><()>())
    } else if TypeId::of::<LIFETIME></LIFETIME><E>() == target {
        let <MUTABLE></MUTABLE> unerased = e.cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, E>>>().deref_mut();
        Some(Mut::new(&<MUTABLE>mut</MUTABLE> unerased._object.error).cast::<LIFETIME></LIFETIME><()>())
    } else {
        None
    }
}


#[cfg(feature = "std")]
<SAFENESS>unsafe</SAFENESS> fn context_drop_rest<C, E>(<MUTABLE></MUTABLE>e: Own<LIFETIME></LIFETIME><ErrorImpl>, <MUTABLE></MUTABLE>target: TypeId)
where
    C: <LIFETIME>'static</LIFETIME>,
    E: <LIFETIME>'static</LIFETIME>,
{
    
    
    if TypeId::of::<LIFETIME></LIFETIME><C>() == target {
        let <MUTABLE></MUTABLE> unerased = e
            .cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><ManuallyDrop<LIFETIME></LIFETIME><C>, E>>>()
            .boxed();
        drop(unerased);
    } else {
        let <MUTABLE></MUTABLE> unerased = e
            .cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, ManuallyDrop<LIFETIME></LIFETIME><E>>>>()
            .boxed();
        drop(unerased);
    }
}


<SAFENESS>unsafe</SAFENESS> fn context_chain_downcast<C>(<MUTABLE></MUTABLE>e: Ref<LIFETIME></LIFETIME><ErrorImpl>, <MUTABLE></MUTABLE>target: TypeId) -> Option<LIFETIME></LIFETIME><Ref<LIFETIME></LIFETIME><()>>
where
    C: <LIFETIME>'static</LIFETIME>,
{
    let <MUTABLE></MUTABLE> unerased = e.cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, Error>>>().deref();
    if TypeId::of::<LIFETIME></LIFETIME><C>() == target {
        Some(Ref::new(&unerased._object.context).cast::<LIFETIME></LIFETIME><()>())
    } else {
        
        let <MUTABLE></MUTABLE> source = &unerased._object.error;
        (vtable(source.inner.ptr).object_downcast)(source.inner.by_ref(), target)
    }
}


#[cfg(anyhow_no_ptr_addr_of)]
<SAFENESS>unsafe</SAFENESS> fn context_chain_downcast_mut<C>(<MUTABLE></MUTABLE>e: Mut<LIFETIME></LIFETIME><ErrorImpl>, <MUTABLE></MUTABLE>target: TypeId) -> Option<LIFETIME></LIFETIME><Mut<LIFETIME></LIFETIME><()>>
where
    C: <LIFETIME>'static</LIFETIME>,
{
    let <MUTABLE></MUTABLE> unerased = e.cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, Error>>>().deref_mut();
    if TypeId::of::<LIFETIME></LIFETIME><C>() == target {
        Some(Mut::new(&<MUTABLE>mut</MUTABLE> unerased._object.context).cast::<LIFETIME></LIFETIME><()>())
    } else {
        
        let <MUTABLE></MUTABLE> source = &<MUTABLE>mut</MUTABLE> unerased._object.error;
        (vtable(source.inner.ptr).object_downcast_mut)(source.inner.by_mut(), target)
    }
}


<SAFENESS>unsafe</SAFENESS> fn context_chain_drop_rest<C>(<MUTABLE></MUTABLE>e: Own<LIFETIME></LIFETIME><ErrorImpl>, <MUTABLE></MUTABLE>target: TypeId)
where
    C: <LIFETIME>'static</LIFETIME>,
{
    
    
    if TypeId::of::<LIFETIME></LIFETIME><C>() == target {
        let <MUTABLE></MUTABLE> unerased = e
            .cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><ManuallyDrop<LIFETIME></LIFETIME><C>, Error>>>()
            .boxed();
        
        drop(unerased);
    } else {
        let <MUTABLE></MUTABLE> unerased = e
            .cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, ManuallyDrop<LIFETIME></LIFETIME><Error>>>>()
            .boxed();
        
        let <MUTABLE></MUTABLE> inner = unerased._object.error.inner;
        drop(unerased);
        let <MUTABLE></MUTABLE> vtable = vtable(inner.ptr);
        
        (vtable.object_drop_rest)(inner, target);
    }
}


#[cfg(all(not(backtrace), feature = "backtrace"))]
#[allow(clippy::unnecessary_wraps)]
<SAFENESS>unsafe</SAFENESS> fn context_backtrace<C>(<MUTABLE></MUTABLE>e: Ref<LIFETIME></LIFETIME><ErrorImpl>) -> Option<LIFETIME></LIFETIME><<LIFETIME></LIFETIME>&Backtrace>
where
    C: <LIFETIME>'static</LIFETIME>,
{
    let <MUTABLE></MUTABLE> unerased = e.cast::<LIFETIME></LIFETIME><ErrorImpl<LIFETIME></LIFETIME><ContextError<LIFETIME></LIFETIME><C, Error>>>().deref();
    let <MUTABLE></MUTABLE> backtrace = ErrorImpl::backtrace(unerased._object.error.inner.by_ref());
    Some(backtrace)
}




#[repr(C)]
pub(crate) struct ErrorImpl<E = ()> {
    vtable: <LIFETIME></LIFETIME>&<LIFETIME>'static</LIFETIME> ErrorVTable,
    backtrace: Option<LIFETIME></LIFETIME><Backtrace>,
    
    
    _object: E,
}



<SAFENESS>unsafe</SAFENESS> fn vtable(<MUTABLE></MUTABLE>p: NonNull<LIFETIME></LIFETIME><ErrorImpl>) -> <LIFETIME></LIFETIME>&<LIFETIME>'static</LIFETIME> ErrorVTable {
    
    *(p.as_ptr() as *const <LIFETIME></LIFETIME>&<LIFETIME>'static</LIFETIME> ErrorVTable)
}



#[repr(C)]
pub(crate) struct ContextError<C, E> {
    pub context: C,
    pub error: E,
}

<SAFENESS></SAFENESS>impl<E> ErrorImpl<LIFETIME></LIFETIME><E> {
    <SAFENESS></SAFENESS>fn erase(<MUTABLE></MUTABLE>&<MUTABLE></MUTABLE>self) -> Ref<LIFETIME></LIFETIME><ErrorImpl> {
        
        
        
        Ref::new(self).cast::<LIFETIME></LIFETIME><ErrorImpl>()
    }
}

<SAFENESS></SAFENESS>impl ErrorImpl {
    pub(crate) <SAFENESS>unsafe</SAFENESS> fn error(<MUTABLE></MUTABLE>this: Ref<LIFETIME></LIFETIME><Self>) -> <LIFETIME></LIFETIME>&(dyn StdError + Send + Sync <LIFETIME>'static</LIFETIME>) {
        
        
        (vtable(this.ptr).object_ref)(this).deref()
    }

    #[cfg(feature = "std")]
    pub(crate) <SAFENESS>unsafe</SAFENESS> fn error_mut(<MUTABLE></MUTABLE>this: Mut<LIFETIME></LIFETIME><Self>) -> <LIFETIME></LIFETIME>&<MUTABLE>mut</MUTABLE> (dyn StdError + Send + Sync <LIFETIME>'static</LIFETIME>) {
        
        

        #[cfg(not(anyhow_no_ptr_addr_of))]
        return (vtable(this.ptr).object_ref)(this.by_ref())
            .by_mut()
            .deref_mut();

        #[cfg(anyhow_no_ptr_addr_of)]
        return (vtable(this.ptr).object_mut)(this);
    }

    #[cfg(any(backtrace, feature = "backtrace"))]
    pub(crate) <SAFENESS>unsafe</SAFENESS> fn backtrace(<MUTABLE></MUTABLE>this: Ref<LIFETIME></LIFETIME><Self>) -> <LIFETIME></LIFETIME>&Backtrace {
        
        
        
        this.deref()
            .backtrace
            .as_ref()
            .or_else(|| {
                #[cfg(backtrace)]
                return Self::error(this).backtrace();
                #[cfg(all(not(backtrace), feature = "backtrace"))]
                return (vtable(this.ptr).object_backtrace)(this);
            })
            .expect("backtrace capture failed")
    }

    #[cold]
    pub(crate) <SAFENESS>unsafe</SAFENESS> fn chain(<MUTABLE></MUTABLE>this: Ref<LIFETIME></LIFETIME><Self>) -> Chain {
        Chain::new(Self::error(this))
    }
}

<SAFENESS></SAFENESS>impl<E> StdError for ErrorImpl<LIFETIME></LIFETIME><E>
where
    E: StdError,
{
    #[cfg(backtrace)]
    <SAFENESS></SAFENESS>fn backtrace(<MUTABLE></MUTABLE>&<MUTABLE></MUTABLE>self) -> Option<LIFETIME></LIFETIME><<LIFETIME></LIFETIME>&Backtrace> {
        Some(<SAFENESS>unsafe</SAFENESS> { ErrorImpl::backtrace(self.erase()) })
    }

    <SAFENESS></SAFENESS>fn source(<MUTABLE></MUTABLE>&<MUTABLE></MUTABLE>self) -> Option<LIFETIME></LIFETIME><<LIFETIME></LIFETIME>&(dyn StdError <LIFETIME>'static</LIFETIME>)> {
        <SAFENESS>unsafe</SAFENESS> { ErrorImpl::error(self.erase()).source() }
    }
}

<SAFENESS></SAFENESS>impl<E> Debug for ErrorImpl<LIFETIME></LIFETIME><E>
where
    E: Debug,
{
    <SAFENESS></SAFENESS>fn fmt(<MUTABLE></MUTABLE>&<MUTABLE></MUTABLE>self, <MUTABLE></MUTABLE>formatter: <LIFETIME></LIFETIME>&<MUTABLE>mut</MUTABLE> fmt::Formatter) -> fmt::Result {
        <SAFENESS>unsafe</SAFENESS> { ErrorImpl::debug(self.erase(), formatter) }
    }
}

<SAFENESS></SAFENESS>impl<E> Display for ErrorImpl<LIFETIME></LIFETIME><E>
where
    E: Display,
{
    <SAFENESS></SAFENESS>fn fmt(<MUTABLE></MUTABLE>&<MUTABLE></MUTABLE>self, <MUTABLE></MUTABLE>formatter: <LIFETIME></LIFETIME>&<MUTABLE>mut</MUTABLE> fmt::Formatter) -> fmt::Result {
        <SAFENESS>unsafe</SAFENESS> { Display::fmt(ErrorImpl::error(self.erase()), formatter) }
    }
}

<SAFENESS></SAFENESS>impl From<LIFETIME></LIFETIME><Error> for Box<LIFETIME></LIFETIME><dyn StdError + Send + Sync <LIFETIME>'static</LIFETIME>> {
    #[cold]
    <SAFENESS></SAFENESS>fn from(<MUTABLE></MUTABLE>error: Error) -> Self {
        let <MUTABLE></MUTABLE> outer = ManuallyDrop::new(error);
        <SAFENESS>unsafe</SAFENESS> {
            
            
            (vtable(outer.inner.ptr).object_boxed)(outer.inner)
        }
    }
}

<SAFENESS></SAFENESS>impl From<LIFETIME></LIFETIME><Error> for Box<LIFETIME></LIFETIME><dyn StdError + Send <LIFETIME>'static</LIFETIME>> {
    <SAFENESS></SAFENESS>fn from(<MUTABLE></MUTABLE>error: Error) -> Self {
        Box::<LIFETIME></LIFETIME><dyn StdError + Send + Sync>::from(error)
    }
}

<SAFENESS></SAFENESS>impl From<LIFETIME></LIFETIME><Error> for Box<LIFETIME></LIFETIME><dyn StdError <LIFETIME>'static</LIFETIME>> {
    <SAFENESS></SAFENESS>fn from(<MUTABLE></MUTABLE>error: Error) -> Self {
        Box::<LIFETIME></LIFETIME><dyn StdError + Send + Sync>::from(error)
    }
}

#[cfg(feature = "std")]
<SAFENESS></SAFENESS>impl AsRef<LIFETIME></LIFETIME><dyn StdError + Send + Sync> for Error {
    <SAFENESS></SAFENESS>fn as_ref(<MUTABLE></MUTABLE>&<MUTABLE></MUTABLE>self) -> <LIFETIME></LIFETIME>&(dyn StdError + Send + Sync <LIFETIME>'static</LIFETIME>) {
        &**self
    }
}

#[cfg(feature = "std")]
<SAFENESS></SAFENESS>impl AsRef<LIFETIME></LIFETIME><dyn StdError> for Error {
    <SAFENESS></SAFENESS>fn as_ref(<MUTABLE></MUTABLE>&<MUTABLE></MUTABLE>self) -> <LIFETIME></LIFETIME>&(dyn StdError <LIFETIME>'static</LIFETIME>) {
        &**self
    }
}

